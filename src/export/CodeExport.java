/*
 * Grady Landers
 * Master's Project - Code name Rubber Duck
 * code exporter super class
 */
package export;

import java.io.File;
import java.io.FileWriter;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

abstract class CodeExport {
	//write opening block comment
	protected static void generateHeader(FileWriter f, String message) {
		try {
			f.append("/*\n * Code auto generated by the Rubber Duck programming tool on " + getNowString()
					+"\n * " + message
					+"\n */"
					+"\npackage output;\n\n");
		}
		catch(Exception e) {
			e.printStackTrace();
		}
	}
	
	//write imports
	protected static void generateImports(FileWriter f, String[] imports, String className) {
		try {
			for(int i=0; i<imports.length; i++) {
				f.append("import " + imports[i] + ";\n");
			}
			f.append("\npublic class "+className+" {\n");
		}
		catch(Exception e) {
			e.printStackTrace();
		}
	}
	
	//get current datetime modified from https://www.javatpoint.com/java-get-current-date
	protected static String getNowString() {
		DateTimeFormatter dtf = DateTimeFormatter.ofPattern("yyyy/MM/dd HH:mm:ss");
		LocalDateTime now = LocalDateTime.now();
		return dtf.format(now); 
	}
	
	//generate static variables for array program
	protected static void generateArrayVariables(FileWriter f, String type, Object[] arr, boolean num, Object target) throws Exception {
		try {
			f.append("\t//variables\n"
					+"\tstatic "+type+"[] arr = {");
			for(int i=0; i<arr.length; i++) {
				if(num) f.append(arr[i].toString());
				else f.append('"'+arr[i].toString()+'"');
				if(i < arr.length-1) f.append(",");
			}
			f.append("};\n");
			
			if(target != null) {
				String t;
				if(num) {
					t = target.toString();
					f.append("\tstatic double target = "+t+";\n");
				}
				else {
					t = '"'+target.toString()+'"';
					f.append("\tstatic String target = "+t+";\n");
				}
			}
			
			f.append("\n");
		}
		catch(Exception e) {
			throw e;
		}
	}
	
	//generate static variables for graph program
	protected static void generateGraphVariables(FileWriter f, boolean num, Object[][] graph, String type, Object target) throws Exception {
		try {
			f.append("\t//variables\n"
					+"\tstatic Object[][] graph = "+graphString(graph, num)+";\n");
			
			if(target != null) {
				if(type.contentEquals("src")) f.append("\tstatic int src = "+target.toString()+";\n");
				else if(type.contentEquals("String")) f.append("\tstatic String target = \""+target.toString()+"\";\n");
				else f.append("\tstatic "+type+" target = "+target.toString()+";\n");
			}
			
			f.append("\n");
		}
		catch(Exception e) {
			throw e;
		}
	}
	
	private static String graphString(Object[][] graph, boolean num) {
		String out = "{{";
		
		if(graph[0][0] == null) {
			for(int j=0; j<graph[0].length; j++) {
				out += "null";
				if(j < graph[0].length-1) out += ",";
			}
		}
		else {
			for(int j=0; j<graph[0].length; j++) {
				if(!num) out += '"'+graph[0][j].toString()+'"';
				else out += graph[0][j].toString();
				if(j < graph[0].length-1) out += ",";
			}
		}
		out += "},";
		
		for(int i=1; i<graph.length; i++) {
			out += "{";
			for(int j=0; j<graph[i].length; j++) {
				out += graph[i][j].toString();
				if(j < graph[i].length-1) out += ",";
			}
			out += "}";
			if(i < graph.length-1) out += ",";
		}
		
		out += "}";
		return out;
	}
	
	//generate both graph and node classes
	protected static void generateDependencies(String path) throws Exception {
		try {
			generateGraph(path);
			generateNode(path);
		}
		catch(Exception e) {
			throw e;
		}
	}
	
	//generate graph class
	private static void generateGraph(String path) throws Exception {
		try {
			File f = new File(path+"Graph.java");
			if(!f.createNewFile()) {
				System.out.println("Graph.java already exists.");
			}
			else {
				FileWriter w = new FileWriter(f);
				
				w.append("/*\n"
						+ " * Grady Landers\n"
						+ " * Master's Project - Code name Rubber Duck\n"
						+ " * graph class for back-end\n"
						+ " * modified from https://www.geeksforgeeks.org/breadth-first-search-or-bfs-for-a-graph/\n"
						+ " */\n"
						+ "\n"
						+ "package output;\n"
						+ "\n"
						+ "import java.util.LinkedList;\n"
						+ "\n"
						+ "public class Graph {\n"
						+ "	private int V; //No. of vertices\n"
						+ "	public LinkedList<Integer> adj[]; //Adjacency Lists\n"
						+ "	\n"
						+ "	// Constructor\n"
						+ "	@SuppressWarnings(\"unchecked\")\n"
						+ "	public Graph(int v) {\n"
						+ "		V = v;\n"
						+ "		adj = new LinkedList[v];\n"
						+ "		for(int i=0; i<v; i++)\n"
						+ "			adj[i] = new LinkedList<Integer>();\n"
						+ "	}\n"
						+ "	\n"
						+ "	// Function to add edge into the graph\n"
						+ "	public void addEdge(int v, int w) {\n"
						+ "		adj[v].add(w); //add w to v's list\n"
						+ "	}\n"
						+ "	\n"
						+ "	// Function to get the size of the graph\n"
						+ "	public int getSize() {\n"
						+ "		return this.V;\n"
						+ "	}\n"
						+ "}\n"
						+ "");
				
				w.close();
			}
		}
		catch(Exception e) {
			throw e;
		}
	}
	
	//generate node class
	private static void generateNode(String path) throws Exception {
		try {
			File f = new File(path+"Node.java");
			if(!f.createNewFile()) {
				System.out.println("Node.java already exists.");
			}
			else {
				FileWriter w = new FileWriter(f);
				
				w.append("/*\n"
						+ " * Grady Landers\n"
						+ " * Master's Project - Code name Rubber Duck\n"
						+ " * Node class for A* Search implementation\n"
						+ " * heavily inspired by https://stackabuse.com/graphs-in-java-a-star-algorithm/\n"
						+ " */\n"
						+ "\n"
						+ "package output;\n"
						+ "\n"
						+ "import java.util.ArrayList;\n"
						+ "\n"
						+ "public class Node implements Comparable<Node> {\n"
						+ "    // Id for readability of result purposes\n"
						+ "    public String id;\n"
						+ "\n"
						+ "    // Parent in the path\n"
						+ "    public Node parent = null;\n"
						+ "\n"
						+ "    public ArrayList<Edge> neighbors;\n"
						+ "\n"
						+ "    // Evaluation functions\n"
						+ "    public double f = Double.MAX_VALUE;\n"
						+ "    public double g = Double.MAX_VALUE;\n"
						+ "    // Hardcoded heuristic\n"
						+ "    public double h; \n"
						+ "\n"
						+ "    Node(String id){\n"
						+ "          this.h = 0;\n"
						+ "          this.id = id;\n"
						+ "          this.neighbors = new ArrayList<>();\n"
						+ "    }\n"
						+ "    \n"
						+ "    public void setH(double h){\n"
						+ "    	  this.h = h;\n"
						+ "    }\n"
						+ "\n"
						+ "    @Override\n"
						+ "    public int compareTo(Node n) {\n"
						+ "          return Double.compare(this.f, n.f);\n"
						+ "    }\n"
						+ "\n"
						+ "    public static class Edge {\n"
						+ "          Edge(int weight, Node node){\n"
						+ "                this.weight = weight;\n"
						+ "                this.node = node;\n"
						+ "          }\n"
						+ "\n"
						+ "          public int weight;\n"
						+ "          public Node node;\n"
						+ "    }\n"
						+ "\n"
						+ "    public void addBranch(int weight, Node node){\n"
						+ "          Edge newEdge = new Edge(weight, node);\n"
						+ "          neighbors.add(newEdge);\n"
						+ "    }\n"
						+ "\n"
						+ "    public double calculateHeuristic(Node target){\n"
						+ "          return this.h;\n"
						+ "    }\n"
						+ "}\n"
						+ "");
				
				w.close();
			}
		}
		catch(Exception e) {
			throw e;
		}
	}
}
